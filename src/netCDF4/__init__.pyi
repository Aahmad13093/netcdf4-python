
import os
from typing import (Any, Generic, Iterable, Literal, Mapping, NoReturn, Self,
                    Sequence, TypeAlias, TypeVar, Union, overload)

import numpy as np
import numpy.typing as npt
from cftime import date2index, date2num, num2date
from typing_extensions import Buffer

__all__ = [
    'Dataset', 'Variable', 'Dimension', 'Group', 'MFDataset', 'MFTime', 'CompoundType',
    'VLType', 'date2num', 'num2date', 'date2index', 'stringtochar', 'chartostring',
    'stringtoarr', 'getlibversion', 'EnumType', 'get_chunk_cache', 'set_chunk_cache',
    'set_alignment', 'get_alignment'
]
__pdoc__ = {'utils': False}

_DatatypeStrOptions: TypeAlias = Literal[
    'S1', 'c', 'i1', 'b', 'B', 'u1', 'i2', 'h', 's', 'u2', 'i4',
    'i', 'l', 'u4', 'i8', 'u8', 'f4', 'f', 'f8', 'd', 'c8', 'c16'
]
_DatatypeNCOptions: TypeAlias = Union[CompoundType, VLType, EnumType]
DatatypeOptions: TypeAlias = Union[_DatatypeStrOptions, _DatatypeNCOptions, npt.DTypeLike]
T_Datatype = TypeVar("T_Datatype", bound=DatatypeOptions)
T_DatatypeNC = TypeVar("T_DatatypeNC", CompoundType, VLType, EnumType)

DimensionsOptions: TypeAlias = Union[str, bytes, Dimension, Iterable[Union[str, bytes, Dimension]]]
CompressionOptions: TypeAlias = Literal[
    'zlib', 'szip', 'zstd', 'blosc_lz','blosc_lz4', 
    'blosc_lz4hc', 'blosc_zlib', 'blosc_zstd', None
]
CompressionLevelOptions: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, None]
AccessModeOptions: TypeAlias = Literal['r', 'w', 'r+', 'a', 'x', 'rs', 'ws', 'r+s', 'as']
FormatOptions: TypeAlias = Literal[
    'NETCDF4', 'NETCDF4_CLASSIC', 'NETCDF3_CLASSIC',
    'NETCDF3_64BIT_OFFSET', 'NETCDF3_64BIT_DATA'
]
DiskFormatOptions: TypeAlias = Literal['NETCDF3', 'HDF5', 'HDF4', 'PNETCDF', 'DAP2', 'DAP4', 'UNDEFINED']
QuantizeOptions: TypeAlias = Literal['BitGroom', 'BitRound', 'GranularBitRound']
EndianOptions: TypeAlias = Literal['native', 'little', 'big']


__version__: str
__netcdf4libversion__: str
__hdf5libversion__: str
__has_rename_grp__: bool
__has_nc_inq_path__: bool
__has_nc_inq_format_extended__: bool
__has_nc_open_mem__: bool
__has_nc_create_mem__: bool
__has_cdf5_format__: bool
__has_parallel4_support__: bool
__has_pnetcdf_support__: bool
__has_parallel_support__: bool
__has_quantization_support__: bool
__has_zstandard_support__: bool
__has_bzip2_support__: bool
__has_blosc_support__: bool
__has_szip_support__: bool
__has_set_alignment__: bool
__has_ncfilter__: bool
is_native_little: bool
is_native_big: bool
default_encoding: str
unicode_error: str
default_fillvals: dict[str, Any]


class NetCDF4MissingFeatureException(Exception):
    def __init__(self, feature: str, version: str): ...


class Dataset:
    def __init__(
        self,
        filename: str | os.PathLike,
        mode: AccessModeOptions = 'r',
        clobber: bool = True,
        format: FormatOptions = 'NETCDF4',
        diskless: bool = False,
        persist: bool = False,
        keepweakref: bool = False,
        memory: Buffer | int | None = None,
        encoding: str | None = None,
        parallel: bool = False,
        comm: Any = None,
        info: Any = None,
        auto_complex: bool = False,
        **kwargs: Any
    ): ...

    @property
    def name(self) -> str: ...
    @property
    def groups(self) -> dict[str, Group]: ...
    @property
    def dimensions(self) -> dict[str, Dimension]: ...
    @property
    def variables(self) -> dict[str, Variable[Any]]: ...
    @property
    def cmptypes(self) -> dict[str, CompoundType]: ...
    @property
    def vltypes(self) -> dict[str, VLType]: ...
    @property
    def enumtypes(self) -> dict[str, EnumType]: ...
    @property
    def data_model(self) -> FormatOptions: ...
    @property
    def file_format(self) -> FormatOptions: ...
    @property
    def disk_format(self) -> DiskFormatOptions: ...
    @property
    def parent(self) -> Dataset | None: ...
    @property
    def path(self) -> str: ...
    @property
    def keepweakref(self) -> bool: ...
    @property
    def auto_complex(self) -> bool: ...
    @property
    def __orthogonal_indexing__(self) -> bool: ...

    def filepath(self, encoding: str | None = None) -> str: ...
    def isopen(self) -> bool: ...
    def close(self) -> memoryview: ...  # only if writing and memory != None, but otherwise people ignore the return None anyway
    def sync(self) -> None: ...
    def set_fill_on(self) -> None: ...
    def set_fill_off(self) -> None: ...

    def createDimension(self, dimname: str, size: int | None = None) -> Dimension: ...
    def renameDimension( self, oldname: str, newname: str) -> None: ...
    @overload
    def createVariable(  # type: ignore
        self,
        varname: str,
        datatype: T_DatatypeNC,
        dimensions: DimensionsOptions = (),
        compression: CompressionOptions = None,
        zlib: bool = False,
        complevel: CompressionLevelOptions = 4,
        shuffle: bool = True,
        szip_coding: Literal['nn', 'ec'] = 'nn',
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: int | None = None,
        endian: EndianOptions = 'native',
        least_significant_digit: int | None = None,
        significant_digits: int | None = None,
        quantize_mode: QuantizeOptions = 'BitGroom',
        fill_value: npt.ArrayLike | bool | None = None,
        chunk_cache: int | None = None
    ) -> Variable[T_DatatypeNC]: ...
    @overload
    def createVariable(
        self,
        varname: str,
        datatype: _DatatypeStrOptions | npt.DTypeLike,
        dimensions: DimensionsOptions = (),
        compression: CompressionOptions = None,
        zlib: bool = False,
        complevel: CompressionLevelOptions = 4,
        shuffle: bool = True,
        szip_coding: Literal['nn', 'ec'] = 'nn',
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: int | None = None,
        endian: EndianOptions = 'native',
        least_significant_digit: int | None = None,
        significant_digits: int | None = None,
        quantize_mode: QuantizeOptions = 'BitGroom',
        fill_value: npt.ArrayLike | bool | None = None,
        chunk_cache: int | None = None
    ) -> Variable[np.dtype]: ...
    def renameVariable(self, oldname: str, newname: str) -> None: ...
    def createGroup(self, groupname: str) -> Group: ...
    def renameGroup(self, oldname: str, newname: str) -> None: ...
    def renameAttribute(self, oldname: str, newname: str) -> None: ...
    def createCompoundType( self, datatype: npt.DTypeLike, datatype_name: str) -> CompoundType: ...
    def createVLType( self, datatype: npt.DTypeLike, datatype_name: str) -> VLType: ...
    def createEnumType( self, datatype: npt.DTypeLike, datatype_name: str, enum_dict: dict[str, int]) -> EnumType: ...

    def ncattrs(self) -> list[str]: ...
    def setncattr_string(self, name: str, value: Any) -> None: ...
    def setncattr(self, name: str, value: Any) -> None: ...
    def setncatts(self, attdict: Mapping[str, Any]) -> None: ...
    def getncattr(self, name: str, encoding: str = 'utf-8') -> Any: ...
    def delncattr(self, name: str) -> None: ...
    def set_auto_chartostring(self, value: bool) -> None: ...
    def set_auto_maskandscale(self, value: bool) -> None: ...
    def set_auto_mask(self, value: bool) -> None: ...
    def set_auto_scale(self, value: bool) -> None: ...
    def set_always_mask(self, value: bool) -> None: ...
    def set_ncstring_attrs(self, value: bool) -> None: ...
    def get_variables_by_attributes(self, **kwargs: Any) -> list[Variable]: ...

    @staticmethod
    def fromcdl(
        cdlfilename: str,
        ncfilename: str | None = None,
        mode: AccessModeOptions = 'a',
        format: FormatOptions = 'NETCDF4'
    ) -> Dataset: ...
    @overload
    def tocdl(
        self,
        coordvars: bool = False,
        data: bool = False,
        outfile: None = None
    ) -> str: ...
    @overload
    def tocdl(
        self,
        coordvars: bool = False,
        data: bool = False,
        *,
        outfile: str
    ) -> None: ...

    def has_blosc_filter(self) -> bool: ...
    def has_zstd_filter(self) -> bool: ...
    def has_bzip2_filter(self) -> bool: ...
    def has_szip_filter(self) -> bool: ...

    def __getitem__(self, elem: str) -> Any: ...  # should be Group | Variable, but this causes too many problems
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def __delattr__(self, name: str): ...
    def __dealloc(self) -> None: ...
    def __reduce__(self) -> NoReturn: ...
    def __enter__(self) -> Dataset: ...
    def __exit__(self, atype, value, traceback) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class Group(Dataset):
    def __init__(self, parent: Group | Dataset, name: str, **kwargs: Any) -> None: ...

    def close(self) -> NoReturn: ...


class Dimension:
    def __init__(self, grp: Group, name: str, size: int | None = None, **kwargs: Any) -> None: ...

    @property
    def name(self) -> str: ...
    @property
    def size(self) -> int: ...

    def group(self) -> Group: ...
    def isunlimited(self) -> bool: ...

    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class Variable(Generic[T_Datatype]):

    @overload
    def __new__(  # type: ignore
        self,
        grp: Group,
        name: str,
        datatype: T_DatatypeNC,
        dimensions: DimensionsOptions = (),
        compression: CompressionOptions = None,
        zlib: bool = False,
        complevel: CompressionLevelOptions = 4,
        shuffle: bool = True,
        szip_coding: Literal['nn', 'ec'] = 'nn',
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: Sequence[int] | None = None,
        endian: EndianOptions = 'native',
        least_significant_digit: int | None = None,
        significant_digits: int | None = None,
        quantize_mode: QuantizeOptions = 'BitGroom',
        fill_value: npt.ArrayLike | bool | None = None,
        chunk_cache: int | None = None,
        **kwargs: Any
    ) -> Variable[T_DatatypeNC]: ...

    @overload
    def __new__(
        self,
        grp: Group,
        name: str,
        datatype: _DatatypeStrOptions | npt.DTypeLike,
        dimensions: DimensionsOptions = (),
        compression: CompressionOptions = None,
        zlib: bool = False,
        complevel: CompressionLevelOptions = 4,
        shuffle: bool = True,
        szip_coding: Literal['nn', 'ec'] = 'nn',
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: Sequence[int] | None = None,
        endian: EndianOptions = 'native',
        least_significant_digit: int | None = None,
        significant_digits: int | None = None,
        quantize_mode: QuantizeOptions = 'BitGroom',
        fill_value: npt.ArrayLike | bool | None = None,
        chunk_cache: int | None = None,
        **kwargs: Any
    ) -> Variable[np.dtype]: ...


    def __init__(
        self,
        grp: Group,
        name: str,
        datatype: T_Datatype,
        dimensions: DimensionsOptions = (),
        compression: CompressionOptions = None,
        zlib: bool = False,
        complevel: CompressionLevelOptions = 4,
        shuffle: bool = True,
        szip_coding: Literal['nn', 'ec'] = 'nn',
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: Sequence[int] | None = None,
        endian: EndianOptions = 'native',
        least_significant_digit: int | None = None,
        significant_digits: int | None = None,
        quantize_mode: QuantizeOptions = 'BitGroom',
        fill_value: npt.ArrayLike | bool | None = None,
        chunk_cache: int | None = None,
        **kwargs: Any
    ) -> None: ...

    @property
    def name(self) -> str: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def datatype(self) -> T_Datatype: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def size(self) -> int: ...
    @property
    def dimensions(self) -> tuple[str, ...]: ...
    @property
    def ndim(self) -> int: ...
    @property
    def scale(self) -> bool: ...
    @property
    def mask(self) -> bool: ...
    @property
    def chartostring(self) -> bool: ...
    @property
    def always_mask(self) -> bool: ...
    @property
    def __orthogonal_indexing__(self) -> bool: ...

    def group(self) -> Group: ...
    def ncattrs(self) -> list[str]: ...
    def setncattr(self, name: str, value: Any) -> None: ...
    def setncattr_string(self, name: str, value: Any) -> None: ...
    def setncatts(self, attdict: Mapping[str, Any]) -> None: ...
    def getncattr(self, name: str, encoding='utf-8'): ...
    def delncattr(self, name: str) -> None: ...
    def filters(self) -> dict[str, Any]: ...
    def quantization(self) -> tuple[int, QuantizeOptions] | None: ...
    def endian(self) -> EndianOptions: ...
    def chunking(self) -> Literal['contiguous'] | list[int] | None: ...
    def get_var_chunk_cache(self) -> tuple[int, int, float]: ...
    def set_var_chunk_cache(
        self,
        size: int | None = None,
        nelems: int | None = None,
        preemption: float | None = None
    ) -> None: ...
    def renameAttribute(self, oldname: str, newname: str) -> None: ...
    def assignValue(self, val: Any) -> None: ...
    def getValue(self) -> Any: ...
    def set_auto_chartostring(self, chartostring: bool) -> None: ...
    def use_nc_get_vars(self, use_nc_get_vars: bool) -> None: ...
    def set_auto_maskandscale(self, maskandscale: bool) -> None: ...
    def set_auto_scale(self, scale: bool) -> None: ...
    def set_auto_mask(self, mask: bool) -> None: ...
    def set_always_mask(self, always_mask: bool) -> None: ...
    def set_ncstring_attrs(self, ncstring_attrs: bool) -> None: ...
    def set_collective(self, value: bool) -> None: ...
    def get_dims(self) -> tuple[Dimension, ...]: ...

    def __delattr__(self, name: str) -> None: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def __getitem__(self, elem: Any) -> np.ndarray: ...
    def __setitem__(self, elem: Any, data: npt.ArrayLike) -> None: ...
    def __array__(self) -> np.ndarray: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class CompoundType:
    dtype: np.dtype
    dtype_view: np.dtype
    name: str

    def __init__(self, grp: Group, dt: npt.DTypeLike, dtype_name: str, **kwargs: Any) -> None: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __reduce__(self) -> NoReturn: ...


class VLType:
    dtype: np.dtype
    name: str | None

    def __init__(self, grp: Group, dt: npt.DTypeLike, dtype_name: str, **kwargs: Any) -> None: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __reduce__(self) -> NoReturn: ...


class EnumType:
    dtype: np.dtype
    name: str
    enum_dict: Mapping[str, int]

    def __init__(
        self,
        grp: Group,
        dt: npt.DTypeLike,
        dtype_name: str,
        enum_dict: Mapping[str, int],
        **kwargs: Any
    ) -> None: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __reduce__(self) -> NoReturn: ...


class MFDataset(Dataset):
    def __init__(
        self,
        files: str | Sequence[str | os.PathLike],
        check: bool = False,
        aggdim: str | None = None,
        exclude: Sequence[str] = [],
        master_file: str | os.PathLike | None = None
    ) -> None: ...


class _Variable:
    def __init__(self, dset, varname, var, recdimname): ...

    def __getattr__(self, name): ...
    def __repr__(self): ...
    def __len__(self): ...
    def __getitem__(self, elem): ...

    def typecode(self): ...
    def ncattrs(self): ...
    def _shape(self): ...
    def set_auto_chartostring(self, val): ...
    def set_auto_maskandscale(self, val): ...
    def set_auto_mask(self, val): ...
    def set_auto_scale(self, val): ...
    def set_always_mask(self, val): ...


class MFTime(_Variable):
    def __init__(
        self,
        time: Variable,
        units=None,
        calendar: Literal['standard', 'gregorian'] | None = None
    ): ...
    def __getitem__(self, elem): ...


def stringtoarr(string, NUMCHARS: int, dtype: str = 'S') -> np.ndarray: ...
def stringtochar(a, encoding: str | bytes | None = 'utf-8') -> np.ndarray: ...
def chartostring(b, encoding: str | bytes | None = 'utf-8') -> np.ndarray: ...

def getlibversion() -> str: ...

def set_alignment(threshold: int, alignment: int): ...
def get_alignment() -> tuple[int, int]: ...

def set_chunk_cache(
    size: int | None = None,
    nelems: int | None = None,
    preemption: float | None = None
) -> None: ...
def get_chunk_cache() -> tuple[int, int, float]: ...
